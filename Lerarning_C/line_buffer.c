/*
	2020年4月16日13:23:52
	scanf 与 行缓冲的一些问题
*/
//case 1
// #include <stdio.h>
// int main()
// {
//     int a, b, c;
//     scanf("%d", &a);
//     scanf("%d", &b);
//     scanf("%d", &c);
//     printf("a=%d, b=%d, c=%d\n", a, b, c);
//     return 0;
// }
/*
注意，换行符也是一个字符，也会进入缓冲区。
系统内部有一个专门用来记录 scanf() 读取到哪个位置的标记，
随着 scanf() 的读取，
该标记会向后移动，下一个 scanf() 就从这个新的位置开始读取。

10 12 23回车
a=10, b=12, c=23
*/

//case 2
// #include <stdio.h>
// int main()
// {
//     int a, b=999;
//     char str[30];
//     printf("b=%d\n", b);
//     scanf("%d", &a);
//     scanf("%d", &b);
//     scanf("%s", str);
//     printf("a=%d, b=%d, str=%s\n", a, b, str);
//     return 0;
// }
/*
匹配失败意味着不会移动内部的位置指针，
此时缓冲区中的内容仍然是liyunfei↙
b=999
100 liyunfei回车
a=100, b=999, str=liyunfei
*/
//case 3
#include <stdio.h>
int main()
{
    int a = 99, b = 88;
    scanf("a=%d", &a);
    // scanf("b=%d", &b);
    scanf("%d", &b);
    printf("a=%d, b=%d\n", a, b);
    return 0;
}
/*
a=99回车
a=99, b=88
a=100 b=200回车
a=100, b=88
输入a=99，按下回车键，程序竟然运行结束了，
只有第一个 scanf() 成功读取了数据，
第二个 scanf() 仿佛没有执行一样，根本没有给用户任何机会去输入数据。

空白符在大部分情况下都可以忽略，
前面的两个例子就是这样。
但是当控制字符串不是以格式控制符 %d、%c、%f 等开头时，
空白符就不能忽略了，它会参与匹配过程，如果匹配失败，
就意味着 scanf() 读取失败了。

本例中，第二个 scanf() 的开头并不是格式控制符，
而是写死的b字符，所以不会忽略换行符，而换行符和b又不匹配，
怎么办呢？没办法，只能读取失败了。

两种输入方式都不行，究竟该如何输入呢？
很简单，不要让两份数据之间有空白符，只能像下面一样输入

a=300b=500
a=300, b=500

修改一下读取b的方式

a=300  400
a=300, b=400

a=300
400
a=300, b=400

*/
