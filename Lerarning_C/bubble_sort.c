/*
	2020年4月16日20:17:16
	冒泡排序
	对数组元素进行排序的方法有很多种，
	比如冒泡排序、归并排序、选择排序、插入排序、快速排序等，
	其中最经典最需要掌握的是「冒泡排序」

	以从小到大排序为例，冒泡排序的整体思想是这样的：
	从数组头部开始，不断比较相邻的两个元素的大小，
	让较大的元素逐渐往后移动（交换两个元素的值），
	直到数组的末尾。经过第一轮的比较，就可以找到最大的元素，
	并将它移动到最后一个位置。
	第一轮结束后，继续第二轮。仍然从数组头部开始比较，
	让较大的元素逐渐往后移动，直到数组的倒数第二个元素为止。
	经过第二轮的比较，就可以找到次大的元素，并将它放到倒数第二个位置。
	以此类推，进行 n-1（n 为数组长度）轮“冒泡”后，
	就可以将所有的元素都排列好。

	整个排序过程就好像气泡不断从水里冒出来，最大的先出来，
	次大的第二出来，最小的最后出来，
	所以将这种排序方式称为冒泡排序（Bubble Sort）。

	第一轮  排序过程
	3  2  4  1    （最初）
	2  3  4  1    （比较3和2，交换）
	2  3  4  1    （比较3和4，不交换）
	2  3  1  4    （比较4和1，交换）
	第一轮结束，最大的数字 4 已经在最后面，
	因此第二轮排序只需要对前面三个数进行比较。

	第二轮  排序过程
	2  3  1  4 （第一轮排序结果）
	2  3  1  4 （比较2和3，不交换）
	2  1  3  4 （比较3和1，交换）
	第二轮结束，次大的数字 3 已经排在倒数第二个位置，
	所以第三轮只需要比较前两个元素。

	第三轮  排序过程
	2  1  3  4  （第二轮排序结果）
	1  2  3  4  （比较2和1，交换）
	
	至此，排序结束。
*/

#include <stdio.h>

int main(){
    int nums[10] = {4, 5, 2, 10, 7, 1, 8, 3, 6, 9};
    int i, j, temp;
    int len = sizeof(nums)/sizeof(nums[0]);
    //冒泡排序算法：进行 n-1 轮比较
    for(i=0; i<len-1; i++)
    {
    	printf("i = %d\n", i);
        //每一轮比较前 n-1-i 个，
        //也就是说，已经排序好的最后 i 个不用比较
        for(j=0; j<len-1-i; j++)
        {
            if(nums[j] > nums[j+1])
            {
                temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
   
    //输出排序后的数组
    for(i=0; i<10; i++){
        printf("%d ", nums[i]);
    }
    printf("\n");
   
    return 0;
}
